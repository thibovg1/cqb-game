-
<!DOCTYPE html>
<html lang="nl">

<head>
    <meta charset="UTF-8">
    <title>CQB Ops: Tactical 3D Infiltration</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Consolas', monospace;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 1px solid rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #0f0;
            text-shadow: 2px 2px 4px #000;
            z-index: 5;
            font-size: 12px;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 1px solid #333;
            z-index: 20;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            font-size: 20px;
        }
    </style>
</head>

<body>

    <div id="loading-screen">BREACH PROTOCOL INITIALIZING...</div>
    <div id="crosshair"></div>

    <div id="instructions" style="display:none;">
        <h2 style="color: #ff0000;">ENEMIES DETECTED IN BUILDING</h2>
        <p>Zuiver alle kamers van vijandelijk contact.</p>
        <p><b>KLIK OM DE MISSIE TE STARTEN</b></p>
        <small>WASD: Bewegen | L-MUIS: Vuren | POSITIES GELADEN UIT GLB</small>
    </div>

    <div id="ui">
        [OPERATOR LOGS]<br>
        POSITION: <span id="pos-display">0, 0, 0</span><br>
        ENEMIES: <span id="enemy-count">0</span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. SETTINGS & LOCATIES ---
        // PAS DEZE COÃ–RDINATEN AAN OP BASIS VAN JOUW HUIS MODEL
        const PLAYER_SPAWN = { x: 0, y: 1.6, z: 10 }; // Jouw startpositie (bijv. buiten voor de deur)

        const ENEMY_SPAWN_POINTS = [
            { x: 5, y: 1, z: -5 },   // Kamer 1
            { x: -7, y: 1, z: -12 }, // Kamer 2
            { x: 3, y: 1, z: -15 },  // Gang
            { x: -4, y: 1, z: 2 }    // Keuken
        ];

        // --- 2. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.1);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(PLAYER_SPAWN.x, PLAYER_SPAWN.y, PLAYER_SPAWN.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        const instr = document.getElementById('instructions');
        instr.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => instr.style.display = 'none');
        controls.addEventListener('unlock', () => instr.style.display = 'block');

        const flashlight = new THREE.SpotLight(0xffffff, 60, 40, Math.PI / 7, 0.4);
        flashlight.castShadow = true;
        camera.add(flashlight);
        flashlight.target.position.z = -1;
        camera.add(flashlight.target);
        scene.add(camera);

        // --- 3. LOADING & ENEMIES ---
        const obstacles = [];
        const enemies = [];
        const loader = new GLTFLoader();

        loader.load('huis.glb', (gltf) => {
            const model = gltf.scene;
            model.traverse((node) => {
                if (node.isMesh) {
                    node.receiveShadow = node.castShadow = true;
                    obstacles.push(node);
                }
            });
            scene.add(model);
            spawnEnemies(); // Roep de vijanden op nadat het huis geladen is
            document.getElementById('loading-screen').style.display = 'none';
            instr.style.display = 'block';
        });

        function spawnEnemies() {
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5 });
            const enemyGeo = new THREE.CapsuleGeometry(0.35, 1.2, 4, 8);

            ENEMY_SPAWN_POINTS.forEach((pos) => {
                // We voegen een beetje willekeur toe aan de spawn positie
                const mesh = new THREE.Mesh(enemyGeo, enemyMat);
                mesh.position.set(
                    pos.x + (Math.random() - 0.5) * 2,
                    pos.y,
                    pos.z + (Math.random() - 0.5) * 2
                );
                mesh.castShadow = true;
                mesh.userData = { alive: true };
                scene.add(mesh);
                enemies.push(mesh);
            });
            document.getElementById('enemy-count').innerText = enemies.length;
        }

        // --- 4. COMBAT & COLLISION ---
        const raycaster = new THREE.Raycaster();

        function shoot() {
            camera.rotation.x += 0.05; // Recoil
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);

            const hits = raycaster.intersectObjects(enemies);
            if (hits.length > 0) {
                const target = hits[0].object;
                if (target.userData.alive) {
                    target.userData.alive = false;
                    target.rotation.z = Math.PI / 2; // Valt om
                    target.position.y = 0.4;
                    updateEnemyCount();
                }
            }
        }

        function updateEnemyCount() {
            const alive = enemies.filter(e => e.userData.alive).length;
            document.getElementById('enemy-count').innerText = alive;
        }

        // --- 5. MOVEMENT LOOP ---
        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', (e) => keys[e.code.toLowerCase().replace('key', '')] = true);
        window.addEventListener('keyup', (e) => keys[e.code.toLowerCase().replace('key', '')] = false);
        window.addEventListener('mousedown', () => { if (controls.isLocked) shoot(); });

        const vel = new THREE.Vector3();
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                vel.x -= vel.x * 10 * delta;
                vel.z -= vel.z * 10 * delta;

                const dirZ = Number(keys.w) - Number(keys.s);
                const dirX = Number(keys.d) - Number(keys.a);

                if (dirZ !== 0) vel.z -= dirZ * 100 * delta;
                if (dirX !== 0) vel.x -= dirX * 100 * delta;

                controls.moveRight(-vel.x * delta);
                controls.moveForward(-vel.z * delta);

                // UI feedback
                document.getElementById('pos-display').innerText =
                    `${Math.round(camera.position.x)}, ${Math.round(camera.position.z)}`;

                camera.rotation.x -= camera.rotation.x * 0.1; // Recoil herstel
                prevTime = time;
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>